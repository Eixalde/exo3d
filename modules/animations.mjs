// NOTE : Animations holds no real value as an object, it will probably either disappear or merge with another class as the animation system changes.
// I kept it here for refactoring purposes, as I can't change what the code does
class Animations {
  animatable
  constructor(scene, { path, planet, satellite, steps }) {
    planet.mesh.animations = []
    const ANIM_SPEED = 6 // Custom parameter : define the number of frames needed between two keys of animation. Higher = slower animation
    // Inspiré du tutoriel de babylon.js sur l'animation avec clés : https://doc.babylonjs.com/start/chap3/animation
    const animPlanet = new BABYLON.Animation(
      'xPlanet',
      'position',
      60,
      BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
      BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
    )
    const planetKeys = new Array(steps + 1) // Il faut compter une position supplémentaire pour boucler l'animation
    for (const i of planetKeys.keys()) {
      planetKeys[i] = {
        frame: ANIM_SPEED * i,
        value: path[i],
      }
    }
    animPlanet.setKeys(planetKeys)
    planet.mesh.animations.push(animPlanet)

    // Reminder : 60 is the fps value, no need to use a variable to stock it
    const planetRotateAnim = new BABYLON.Animation(
      'rotateAnim',
      'rotation.y',
      60,
      BABYLON.Animation.ANIMATIONTYPE_FLOAT,
      BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
    )
    const PLANET_REVOLUTION_PERIOD = 50 // Arbitrary period of revolution (in frames) !! Warning : do not make it equal to PRECISION_STEPS (see planets_revolving.js)
    const planetRotateKeys = [
      { frame: 0, value: 2 * Math.PI }, // Counterclockwise rotation, from 2*pi to 0
      { frame: ANIM_SPEED * PLANET_REVOLUTION_PERIOD, value: 0 },
    ]

    planetRotateAnim.setKeys(planetRotateKeys)
    planet.mesh.animations.push(planetRotateAnim)

    // Inspiré de l'exemple suivant : https://www.babylonjs-playground.com/#14EGUT#26
    this.animatable = scene.beginAnimation(
      planet.mesh,
      0,
      ANIM_SPEED * steps,
      true
    ) // From first frame "0" to last "ANIM_SPEED*steps"

    // The following system of movement animation was used for the planet, except this one is a bit shorter because it doesn't need to show the trajectory
    // It also important to note that any movement/rotation made by the planet is applied to its children, so the satellite rotates around the planet by default
    // This movement just enables a different rotation (faster, slower, clockwise...)
    const satelliteMoveAnim = new BABYLON.Animation(
      'satelliteMoveAnim',
      'position',
      60,
      BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
      BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
    )
    const SATELLITE_REVOLUTION_PERIOD = 25 //Arbitrary period for the satellite
    const satelliteKeys = new Array(SATELLITE_REVOLUTION_PERIOD + 1) //One more point to close the trajectory
    for (const i of satelliteKeys.keys()) {
      satelliteKeys[i] = {
        frame: ANIM_SPEED * i,
        value: new BABYLON.Vector3(
          satellite.distanceToParent *
            Math.cos((Math.PI / (SATELLITE_REVOLUTION_PERIOD / 2)) * i),
          0,
          satellite.distanceToParent *
            Math.sin((Math.PI / (SATELLITE_REVOLUTION_PERIOD / 2)) * i)
        ),
      }
    }
    satelliteMoveAnim.setKeys(satelliteKeys)
    // TODO : regroup all animations into one group, also make them generated by another function
    // NOTE : as this animation isn't part of the "animatable" variable in planets_revolving.js, the speed emulation function can't affect it
    // That's why the TODO shall fix this
    satellite.mesh.animations = []
    satellite.mesh.animations.push(satelliteMoveAnim)
    scene.beginAnimation(
      satellite.mesh,
      0,
      ANIM_SPEED * SATELLITE_REVOLUTION_PERIOD,
      true
    )
  }
}

export { Animations }
